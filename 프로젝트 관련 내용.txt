restaurant-management-system/
├── docs/                 				# 문서들 
├── backend/                				# 백엔드
├── restaurant-operations-web/            	# React 사장 관리, 손님 주문 웹 
├── restaurantStaffApp/              		# React Native 직원 앱 
├── 일정.txt
└──  프로젝트 관련 내용.txt


prisma 띄울 때 순서가 compose.yml 을 최상위 폴더인 restaurant-management-system에 해서 거기로 이동한다음 docker compose up -d 명령어 실행
명령어 전 docker desktop 켜논상태여야 됌
그 후 backend 폴더에서 npx prisma studio 실행 하면 gui 툴 뜸 



restaurant-operations-web	(레스토랑 운영 관리)	==	사장, 손님		(웹	react)			qr 정보에는 상점id, 테이블 번호 등, 각 상점 별로 테이블 별 qr 생성 가능

	React (웹)
	클래스 이름, HTML 속성 등: 케밥 케이스가 일반적입니다.
	예시: <div class="my-header-wrap"></div>

	하지만 JSX에서는 카멜 케이스가 대부분입니다.
	예시: <div className="myHeaderWrap"></div>
	이벤트, 속성: <button onClick={...} /> (camelCase)



restaurantStaffApp	(레스토랑 직원)			==	직원			(앱	react_native)

	reactNative는 컴포넌트는 파스칼 딴거는 왠만하면 카멜케이스?


//
프로젝트 사용 기술 및 기술별 역할 정리
한 줄 요약:  프런트는 화면과 상호작용, 백엔드는 비즈니스 로직과 API, DB는 영속 데이터, 소켓은 실시간 통신, 배포는 실행·호스팅을 맡고, 로컬 Docker는 개발용 인프라(특히 DB)를 손쉽게 띄우는 데 쓴다.

프런트엔드
React: 웹 관리자/고객용 화면을 구성하고 상태관리, 라우팅, API 호출로 백엔드와 연동한다. 빌드 후 정적 자산으로 배포된다.
React Native: 직원용 모바일 앱 UI/네이티브 브리지로 기능을 제공하고, 백엔드 API·소켓과 통신한다.

백엔드
Node.js/Express: 주문 생성/조회/승인 등 비즈니스 로직과 REST API 라우팅을 담당한다. 인증, 권한, 검증, 로깅, /health 같은 헬스 체크 엔드포인트를 제공한다.

데이터베이스
PostgreSQL: 주문·메뉴·테이블·직원 등 핵심 데이터를 영속 저장한다. 트랜잭션, 인덱스, 관계 모델로 정합성과 성능을 보장한다.
Prisma: 스키마 정의(prisma/schema.prisma), 마이그레이션(migrate), 타입 안전한 ORM 쿼리로 DB 접근을 단순화한다. 초기화(init), 마이그레이션 배포(deploy), 시드(seed)에 사용한다.

실시간 통신
Socket.IO: 주문 생성/상태 변경, 알림, 주방/홀 모니터링을 실시간 이벤트로 전달한다. 연결 유지, 재연결, 네임스페이스/룸, 인증 토큰 연동 등을 처리한다.

배포/호스팅
Vercel(프런트): 프런트엔드 정적/서버 기능(프로젝트에 따라)을 자동 빌드·캐시·CDN 배포한다. 커밋 트리거로 미리보기/프로덕션 배포를 제공한다.
Render(백엔드): Express/Socket.IO 서버를 지속 실행하고 환경변수, 로그, 스케일링, 헬스체크, 배포 훅(프리-디플로이에서 prisma migrate deploy 등)을 관리한다. 관리형 Postgres도 선택 가능하다.

로컬 개발 인프라
Docker(로컬): 개발 머신에 Postgres(필요 시 Redis)를 컨테이너로 띄워 설치 없이 동일한 환경을 재현한다. 
docker-compose로 DB → API 순서 의존성, 볼륨(데이터 보존), 포트 매핑을 선언적으로 관리한다. Prisma init/migrate/seed와 /health 확인을 로컬에서 일관되게 수행한다.

연결 관계 요약
프런트(React/React Native) → 백엔드(Express)로 HTTP(API)와 WebSocket(Socket.IO) 요청을 보낸다.
백엔드(Express/Socket.IO) ↔ PostgreSQL로 Prisma를 통해 읽기/쓰기한다.
로컬에서는 Docker 컨테이너의 Postgres에 연결해 개발/테스트하고, 프로덕션에서는 Render의 서비스/DB로 전환한다.
배포는 프런트는 Vercel, 백엔드는 Render가 담당하며, 도메인/SSL/스케일링 등 운영 편의 기능을 제공한다.
//


프론트엔드(React, React Native), 
백엔드(Node.js/Express), 
데이터베이스(PostgreSQL), 
실시간 통신(Socket.IO), 
배포(Render/Vercel)로 구성된 웹 애플리케이션 아키텍처이다. 각 컴포넌트는 HTTP API와 웹소켓 이벤트로 연결되고, 설정은 환경 변수로 관리한다.

	Vercel은 무료 웹 배포, Render은 무료 서버 배포 (백엔드/소켓 서버)(데이터베이스는 Render의 매니지드 Postgres 같은 별도 DB 서비스로 생성해 연결)



vercel은 websocket 이 안됌 공식 문서적으로
>>
Vercel은 WebSocket 연결을 직접 지원하지 않으므로, Node.js 서버에서 Express와 Socket.IO를 사용하여 백엔드를 구축하고,
Render 또는 Railway와 같은 PaaS(Platform as a Service)에 배포해야 합니다. 
프론트엔드는 Vercel에 배포한 후, 백엔드 서버의 Socket.IO 엔드포인트에 wss:// 또는 ws:// 프로토콜을 사용하여 연결합니다. 




요구사항 명세서 작성		(react 웹(사장님, 손님), react native 앱(직원))

# 데모 시나리오 1: QR 주문 플로우
## 전제조건
- 사장이 웹에서 상점과 메뉴를 등록해둔 상태
- 테이블별 QR 코드가 생성되어 있음

## 시나리오 단계
1. 손님이 테이블의 QR 코드를 스마트폰으로 스캔
2. 손님 전용 웹페이지로 자동 이동 (매장명, 테이블 번호 확인)		이동시 패러미터 형식? 주소 이동해서 패러미터 값으로 테이블 번호 구분? 유저가 주소 값 수정시 처음 테이블 번호하고 if 해서 예외처리
3. 메뉴 목록 확인 (가격, 이미지, 품절 여부)		다른테이블이 주문시 품절 여부 실시간 동기화?		주문시 한번더 품절 여부 api로 확인 후 가능(2중 체크)
4. 원하는 메뉴 선택 및 수량 조정	
5. 장바구니에서 최종 확인 후 주문
6. 주문 완료 화면 및 주문번호 표시			주문번호는 하루 매장 방문주문 순서로 순차적, 주문순서목록이 있어 자기가 몇번째인지 확인해서 나올 시간 유추 가능?

## 성공 기준
- QR 스캔부터 주문 완료까지 3분 이내
- 모바일 브라우저에서 매끄러운 동작		ui는 핸드폰 최적화
- 중복 주문 방지 확인






# 데모 시나리오 2: 실시간 주문 알림
## 전제조건
- 직원이 직원 앱에 로그인한 상태
- 손님이 주문을 완료한 상황

## 시나리오 단계
1. 손님 주문 완료 시 직원 앱에 즉시 푸시 알림
2. 직원이 알림 터치 시 주문 상세 화면 이동
3. 주문 내용 확인 (메뉴, 수량, 테이블, 시간)
4. 주문 상태를 "접수 → 조리중 → 완료"로 변경		접수대기 > 접수 > 전달완료		이렇게가 더 나을듯?
5. 상태 변경 시 손님 화면에도 실시간 반영		나중엔 카톡알람? 근데 이거 하려면 오픈톡이였나? 그거 만들어야 돼는데 회사 서류 같은거 필요한걸로 알음

## 성공 기준
- 주문 발생부터 알림까지 1초 이내
- 앱이 백그라운드에 있어도 알림 수신
- 상태 변경이 즉시 손님 화면에 반영





# 데모 시나리오 3: 실시간 메뉴 동기화
## 전제조건
- 사장이 사장 웹에 로그인
- 손님이 손님 웹에서 메뉴 확인 중

## 시나리오 단계
1. 사장이 웹에서 특정 메뉴의 가격을 수정
2. 또는 메뉴를 품절로 변경
3. 수정 내용이 즉시 손님 웹 화면에 반영
4. 직원 앱에서도 동일한 정보로 업데이트

## 성공 기준
- 사장 수정부터 손님 화면 반영까지 1초 이내
- 새로고침 없이 자동 업데이트
- 여러 손님이 동시에 보고 있어도 모두 동기화











-- User 테이블 (사용자 관리)
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(20) NOT NULL, -- 'OWNER', 'STAFF'
    name VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Store 테이블 (상점 정보)
CREATE TABLE stores (
    id SERIAL PRIMARY KEY,
    owner_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    address VARCHAR(500),
    phone VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- StaffStore 테이블 (직원-상점 연결)
CREATE TABLE staff_stores (
    id SERIAL PRIMARY KEY,
    staff_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    store_id INTEGER REFERENCES stores(id) ON DELETE CASCADE,
    hourly_wage INTEGER, -- 시급 (원)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(staff_id, store_id)
);

-- Table 테이블 (매장 테이블 관리)
CREATE TABLE tables (
    id SERIAL PRIMARY KEY,
    store_id INTEGER REFERENCES stores(id) ON DELETE CASCADE,
    name VARCHAR(50) NOT NULL, -- '1번 테이블', 'A-1' 등
    qr_token VARCHAR(255) UNIQUE NOT NULL,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- MenuItem 테이블 (메뉴 관리)
CREATE TABLE menu_items (
    id SERIAL PRIMARY KEY,
    store_id INTEGER REFERENCES stores(id) ON DELETE CASCADE,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    price INTEGER NOT NULL, -- 가격 (원)
    image_url VARCHAR(500),
    category VARCHAR(100), -- '메인', '음료', '디저트' 등
    is_available BOOLEAN DEFAULT true,
    display_order INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Order 테이블 (주문 관리)
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    store_id INTEGER REFERENCES stores(id) ON DELETE CASCADE,
    table_id INTEGER REFERENCES tables(id) ON DELETE SET NULL,
    status VARCHAR(20) DEFAULT 'PENDING', -- 'PENDING', 'COOKING', 'DONE', 'CANCELLED'
    total_amount INTEGER NOT NULL,
    customer_memo TEXT, -- 고객 요청사항
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- OrderItem 테이블 (주문 상세 항목)
CREATE TABLE order_items (
    id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(id) ON DELETE CASCADE,
    menu_item_id INTEGER REFERENCES menu_items(id) ON DELETE CASCADE,
    quantity INTEGER NOT NULL,
    unit_price INTEGER NOT NULL, -- 주문 당시 가격 (스냅샷)
    item_name VARCHAR(200) NOT NULL, -- 주문 당시 메뉴명 (스냅샷)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- IdempotencyKey 테이블 (중복 주문 방지)
CREATE TABLE idempotency_keys (
    id SERIAL PRIMARY KEY,
    key_value VARCHAR(255) UNIQUE NOT NULL,
    scope VARCHAR(50) NOT NULL, -- 'order_creation' 등
    order_id INTEGER REFERENCES orders(id),
    request_hash VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NOT NULL
);



관계도 그리기
온라인 도구 사용: draw.io, Lucidchart, dbdiagram.io
또는 간단히 텍스트로 관계 정리:
User (1) ----> (N) Store : owner_id
User (N) <---> (N) Store : staff_stores 테이블로 다대다
Store (1) ----> (N) Table : store_id
Store (1) ----> (N) MenuItem : store_id  
Store (1) ----> (N) Order : store_id
Table (1) ----> (N) Order : table_id
Order (1) ----> (N) OrderItem : order_id
MenuItem (1) ----> (N) OrderItem : menu_item_id





api 문서 종류
# API 엔드포인트 목록

## 인증 관련 (3개)
POST   /auth/register     # 사장 회원가입
POST   /auth/login        # 로그인 (사장/직원)
POST   /auth/refresh      # 토큰 갱신

## 상점 관리 (4개)
POST   /stores            # 상점 생성 (사장)
GET    /stores/:id        # 상점 조회
PUT    /stores/:id        # 상점 정보 수정 (사장)
GET    /stores/:id/stats  # 상점 통계 (주문량, 매출)

## 직원 관리 (2개)
POST   /stores/:id/staff  # 직원 추가 (사장)
GET    /stores/:id/staff  # 직원 목록 조회 (사장)

## 테이블 관리 (3개)
POST   /stores/:id/tables # 테이블 생성 (사장)
GET    /stores/:id/tables # 테이블 목록 (사장)
PUT    /tables/:id/qr     # QR 코드 재생성 (사장)

## 메뉴 관리 (5개)
POST   /stores/:id/menu-items    # 메뉴 추가 (사장)
GET    /stores/:id/menu-items    # 메뉴 목록 (사장용)
PUT    /menu-items/:id           # 메뉴 수정 (사장)
DELETE /menu-items/:id           # 메뉴 삭제 (사장)
GET    /public/stores/:id/menu   # 메뉴 조회 (손님용, 인증 불필요)

## 주문 관리 (4개)
POST   /public/orders            # 주문 생성 (손님, 인증 불필요)
GET    /stores/:id/orders        # 주문 목록 (직원)
PUT    /orders/:id/status        # 주문 상태 변경 (직원)
GET    /orders/:id               # 주문 상세 조회

## 기타 (2개)
GET    /health                   # 서버 상태 체크
GET    /public/tables/:token     # QR 토큰으로 테이블 정보 조회

총 23개 API

